function calculateAndPlotMeanEvents(meanWindow)

% Инициализация переменных и создание GUI
global Fs N time chosen_time_interval cond ch_inxs m_coef 
global data time_in shiftCoeff eventTable
global lfp hd spks multiax lineCoefficients
global channelNames numChannels channelEnabled scalingCoefficients tableData
global matFilePath channelSettingsFilePath
% Глобальная переменная для хранения текущего множителя времени
global timeUnitFactor selectedUnit
global saved_time_interval
global meanData timeAxis initialDir
global events event_inx events_exist event_comments
global stims stim_inx stims_exist
global lastOpenedFiles
global updatedData
global zavp newFs selectedCenter
global time_back time_forward
global figure_position timeForwardEdit
global meanSaveButton saveDataButton
global std_coef show_spikes binsize show_CSD % спайки/CSD
global events_detected
global ev_hists ch_hists 
global ch_labels_l colors_in_l  widths_in_l
global add_event_settings
global mean_group_ch timeSlider menu_visible csd_avaliable filter_avaliable filterSettings
global channelTable

[~, titlename, ~] = fileparts(matFilePath);

params.events = events;
params.figure = figure('Name', 'Mean Event Data'); % Создание нового окна для графика;
params.meanWindow = meanWindow;
params.hd = hd;
params.channelSettings = get(channelTable, 'Data');
params.Fs = Fs;
params.lfp = lfp;
params.N = N;
params.time = time;
params.binsize = binsize;
params.spk_threshold = std_coef;
params.spks = spks;
params.shiftCoeff = shiftCoeff;
params.titlename = titlename;
params.show_spikes = show_spikes;
params.ch_inxs = find([c.channelSettings{:, 2}]); % Индексы активированных каналов
params.show_CSD = true;

[f, calculation_result] = plotMeanEvents(params)

    % Получение данных событий и настроек каналов
    ch_labels = hd.recChNames(:);

%         events = eventTable.Data;
    channelSettings = get(channelTable, 'Data');
    activeChannels = find([channelSettings{:, 2}]); % Индексы активных каналов
    scalingCoefficients = [channelSettings{:, 3}]; % Масштабирующие коэффициенты

    colors_in = channelSettings(:, 4)';
    widths_in = [channelSettings{:, 5}];

    % Подготовка данных для среднего
    meanData = zeros(round(meanWindow * Fs), size(lfp, 2));
    numEvents = length(events);

    for i = 1:numEvents
        % Вычисление индексов окна вокруг события
        eventIdx = round(events(i) * Fs);
        windowStart = max(eventIdx - round(meanWindow * Fs / 2), 1);
        windowEnd = min(windowStart + round(meanWindow * Fs) - 1, N);

        if windowEnd < size(lfp, 1)            
            % Добавление данных в среднее
            meanData = meanData + lfp(windowStart:windowEnd, :) - nanmedian(lfp(windowStart:windowEnd, :));
        end
    end

    % Нормализация среднего
    meanData = meanData / numEvents;

    % Считаем средние спайки

    % show spikes
    ev_hists = [];
    if show_spikes
        clear evs
        for i = 1:numEvents
            % Вычисление индексов окна вокруг события
            eventIdx = round(events(i) * Fs);
            windowStart = max(eventIdx - round(meanWindow * Fs / 2), 1);
            windowEnd = min(windowStart + round(meanWindow * Fs) - 1, N);

            if windowEnd < size(lfp, 1)                      
                % Окно события
                time_start = time(windowStart);
                time_end = time(windowEnd);
                c = 0;

                time_interval = [time_start, time_end];% s
                edges = time_interval(1):binsize:time_interval(2);

                % Смотрим что на каждом канале для этого эвента
                ch_hists = [];
                for ch_inx = ch_inxs
                    c = c+1;
%                     offset = offsets(c) ;
                    spk = spks(ch_inx).tStamp/1000;
                    ampl = abs(spks(ch_inx).ampl);
                    cond_in_event = spk >= time_interval(1) & spk < time_interval(2) ...
                        & ampl > std_coef*std(ampl);
                    spikes_in_event = spk(cond_in_event);
                    hist_data = histcounts(spikes_in_event, edges);
                    ch_hists = [ch_hists; hist_data];
                end
%                 ev_hists = [ev_hists, ch_hists];
                evs(i, :, :) = ch_hists;
            end
        end
        ev_hists = squeeze(mean(evs,1));
    end


    % Отображение среднего
    f2 = figure('Name', 'Mean Event Data'); % Создание нового окна для графика

    hold on
%         sidePanel = uipanel('Parent', f2, 'Position', [.01 .01 .7 .13]);
    % Кнопка для сохранения фигуры на среднем
    meanSaveButton = uicontrol('Style', 'pushbutton', 'String', 'Save Figure', 'Position', [74  388, 80, 30], 'Callback', @(src, event) saveFigure(f2));

    % Кнопка для сохранения данных
    saveDataButton = uicontrol('Style', 'pushbutton', 'String', 'Save Data', 'Position', [160  388, 80, 30], 'Callback', @(src, event) saveMeanData());

    function saveMeanData()   
        [path, name, ~] = fileparts(matFilePath);
        defaultFileName = fullfile(path, [name '_data.mean']);                
        [file,path] = uiputfile('*.mean','Save Data As', defaultFileName);
        if isequal(file,0) || isequal(path,0)
           disp('User canceled save');
        else
           timeAxis = pl_timeAxis;
           save(fullfile(path,file), 'meanData', 'events', 'channelSettings', ...
               'activeChannels', ...
        'scalingCoefficients', 'Fs', 'N', 'time', 'show_spikes', ...
        'binsize', 'std_coef', 'ch_inxs', 'ev_hists', ...
        'timeAxis', 'ch_labels', 'shiftCoeff', 'widths_in', 'colors_in');
        end
    end

    start_time = -meanWindow / 2;
    end_time = meanWindow / 2;

    ch_enabled = repmat(false, length(ch_labels), 1);    
    ch_enabled(activeChannels) = true;

    pl_timeAxis = linspace(start_time, end_time, size(meanData, 1));
    pl_meanData =  meanData.* scalingCoefficients;

    pl_meanData = pl_meanData(:, ch_enabled);
    pl_ch_labels = ch_labels(ch_enabled);
    pl_shiftCoeff = shiftCoeff;
    pl_widths_in = widths_in(ch_enabled);
    pl_colors_in = colors_in(ch_enabled);       

    if show_CSD
        csdPlotting(pl_timeAxis, pl_meanData)
    end

    offsets = multiplot(pl_timeAxis, pl_meanData, ...
    'ChannelLabels', pl_ch_labels, ...
    'shiftCoeff',pl_shiftCoeff, ...
    'linewidth', pl_widths_in, ...
    'color', pl_colors_in);

    if not(isempty(ev_hists))
        mua_x = linspace(start_time, end_time, size(ev_hists, 2));
        im = imagesc(mua_x, offsets, ev_hists);
        uistack(im, 'bottom'); % Перемещение изображения на задний план
    end        

    xlabel('Time (s)');
    ylabel('Mean Value');
    [path, name, ~] = fileparts(matFilePath);
    title([name, ', ', num2str(numEvents), ' events'], 'interpreter', 'none')        

    ylim([offsets(end)-shiftCoeff, offsets(1)+shiftCoeff])
    xlim([start_time, end_time])
end